"""Core regex processing logic for text extraction and pattern generation."""

import logging
import re
from collections.abc import Iterator

from grex import RegExpBuilder

from texthunter.api.schemas import MatchResult

logger = logging.getLogger(__name__)


def extract_matches(
    text_content: dict[str, dict[int, str]],
    keyword_regex: str,
    file_identifier_regex: str | None = None,
    context_chars: int = 20,
) -> Iterator[MatchResult]:
    """Apply keyword regex to text content and yield match results.

    Args:
        text_content: Map of filename -> {page_number: text_content}
        keyword_regex: Regex pattern to find matches
        file_identifier_regex: Optional regex to extract metadata from filenames
        context_chars: Number of characters to include around match

    Yields:
        MatchResult objects for each match found

    """
    logger.debug("Compiling keyword regex: %s", keyword_regex)
    try:
        pattern = re.compile(keyword_regex)
    except re.error as e:
        logger.error("Invalid keyword regex: %s", e)
        raise ValueError(f"Invalid keyword regex: {e}") from e

    file_pattern = None
    if file_identifier_regex:
        logger.debug("Compiling file identifier regex: %s", file_identifier_regex)
        try:
            file_pattern = re.compile(file_identifier_regex)
        except re.error as e:
            logger.error("Invalid file identifier regex: %s", e)
            raise ValueError(f"Invalid file identifier regex: {e}") from e

    total_matches = 0
    for filename, pages in text_content.items():
        logger.debug("Processing file: %s (%d pages)", filename, len(pages))

        # Extract file metadata if pattern provided
        project_id = None
        sheet_no = None
        if file_pattern:
            file_match = file_pattern.search(filename)
            if file_match:
                groups = file_match.groups()
                if len(groups) >= 1:
                    project_id = groups[0]
                if len(groups) >= 2:
                    sheet_no = groups[1]
                logger.debug(
                    "File metadata extracted: project_id=%s, sheet_no=%s",
                    project_id,
                    sheet_no,
                )

        # Search each page
        for page_num, text in pages.items():
            page_matches = 0
            for match in pattern.finditer(text):
                # Extract context around match
                start = max(0, match.start() - context_chars)
                end = min(len(text), match.end() + context_chars)
                context = text[start:end]

                # Add ellipsis if truncated
                if start > 0:
                    context = "..." + context
                if end < len(text):
                    context = context + "..."

                page_matches += 1
                total_matches += 1

                yield MatchResult(
                    source_file=filename,
                    project_id=project_id,
                    sheet_no=sheet_no,
                    page=int(page_num),
                    match_found=match.group(),
                    context=context,
                )

            if page_matches > 0:
                logger.debug("Page %d: found %d matches", page_num, page_matches)

    logger.info("Total matches found: %d", total_matches)


def guess_regex(examples: list[str]) -> tuple[str, str]:
    """Generate a regex pattern from example strings using grex.

    Args:
        examples: List of example strings (minimum 2)

    Returns:
        Tuple of (pattern, explanation)

    """
    logger.debug("Generating regex from %d examples using grex", len(examples))

    if len(examples) < 2:
        raise ValueError("At least 2 examples required")

    try:
        reb = RegExpBuilder.from_test_cases(examples)
        pattern = (
            reb.with_conversion_of_digits()
            .with_conversion_of_words()
            .without_anchors()
            .build()
        )

        # Validate the pattern
        try:
            compiled = re.compile(pattern)
        except re.error as e:
            raise ValueError(f"Generated regex is invalid: {e}") from e

        # Check if pattern matches all examples
        all_match = all(compiled.fullmatch(ex) for ex in examples)
        if not all_match:
            raise ValueError(
                "Generated regex does not match all examples."
                " Please add regex manually."
            )

        explanation = "Regex generated by TextHunter from examples"
        logger.info("Generated pattern: %s", pattern)
        return pattern, explanation

    except Exception as e:  # TODO: specify exception
        logger.error("Failed to generate regex: %s", e)
        raise ValueError(
            f"Failed to generate regex from examples: {e}. Please add regex manually."
        ) from e

